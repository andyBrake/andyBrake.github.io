
#ARM微处理器的工作状态一般有两种,并可在两种状态之间切换:
- 第一种为ARM状态,此时处理器执行32位的字对齐的ARM指令;
- 第二种为Thumb状态,此时处理器执行16位的、半字对齐的Thumb指令
***

#ARM微处理器支持7种运行模式,分别为:
- 用户模式(usr): ARM处理器正常的程序执行状态
- 快速中断模式(fiq): 用于高速数据传输或通道处理
- 外部中断模式(irq): 用于通用的中断处理
- 管理模式(svc): 操作系统使用的保护模式
- 数据访问终止模式(abt): 当数据或指令预取终止时进入该模式,可用于虚拟存储及存储保护。
- 系统模式(sys): 运行具有特权的操作系统任务。
- 未定义指令中止模式(und):当未定义的指令执行时进入该模式,可用于支持硬件协处理器的软件仿真。
***

#ARM微处理器共有37个32位寄存器,其中31个为通用寄存器,6个为状态寄存器
- 未分组寄存器：R0 - R7， 在所有的工作模式下，未分组寄存器都指向同一个物理寄存器。
- 分组寄存器： R8 - R14，对于R8-R12来说，每个寄存器对应两个不同的物理寄存器，分别为FIQ模式和其他模式下使用。对于R13，R14来说，每个寄存器对应6个不同的物理寄存器，其中用户模式和系统模式共用一个，另外五个物理寄存器对应五种不同的工作模式。
- R13 又叫堆栈指针寄存器SP。
- R14 又叫程序链接寄存器，用于记录函数跳转时的返回地址。
- R15 叫做程序计数器PC，用于记录程序指令。
- R16 叫当前程序状态寄存器 CPSR，另外还有5个用于备份的程序状态寄存器SPSRs。CPSR的低5bit是工作模式位。
- 
***


#寄存器R15用作程序计数器(PC)。在ARM状态下,位[1:0]为0,位[31:2]用于保存PC;在Thumb 状态下,位[0]为0,位[31:1]用于保存PC;

***


#3-1 ARM 指令及功能描述
| 助记符 | 指令功能描述                                |
| ------ | ------------------------------------------- |
| ADC    | 带进位加法指令                              |
| ADD    | 加法指令                                    |
| AND    | 逻辑与指令                                  |
| B      | 跳转指令                                    |
| BIC    | 位清零指令                                  |
| BL     | 带返回的跳转指令                            |
| BLX    | 带返回和状态切换的跳转指令                  |
| BX     | 带状态切换的跳转指令                        |
| CDP    | 协处理器数据操作指令                        |
| CMN    | 比较反值指令                                |
| CMP    | 比较指令                                    |
| EOR    | 异或指令                                    |
| LDC    | 存储器到协处理器的数据传输指令              |
| LDM    | 加载多个寄存器指令                          |
| LDR    | 存储器到寄存器的数据传输指令                |
| MCR    | 从 ARM 寄存器到协处理器寄存器的数据传输指令 |
| MLA    | 乘加运算指令                                |
| MOV    | 数据传送指令                                |
| MRC    | 从协处理器寄存器到 ARM 寄存器的数据传输指令 |
| MRS    | 传送 CPSR 或 SPSR 的内容到通用寄存器指令    |
| MSR    | 传送通用寄存器到 CPSR 或 SPSR 的指令        |
| MUL    | 32 位乘法指令                               |
| MLA    | 32 位乘加指令                               |
| MVN    | 数据取反传送指令                            |
| ORR    | 逻辑或指令                                  |
| RSB    | 逆向减法指令                                |
| RSC    | 带借位的逆向减法指令                        |
| SBC    | 带借位减法指令                              |
| STC    | 协处理器寄存器写入存储器指令                |
| STM    | 批量内存字写入指令                          |
| STR    | 寄存器到存储器的数据传输指令                |
| SUB    | 减法指令                                    |
| SWI    | 软件中断指令                                |
| SWP    | 交换指令                                    |
| TEQ    | 相等测试指令                                |
| TST    | 位测试指令                                  |
***
##例子：
> `LDR r0, 0x12345678 ` 把__0x12345678这个地址中的值__写入r0中。而mov不能实现这个功能，mov只能在寄存器之间移动数据，或者把立即数移动到寄存器中，这个和x86这种CISC架构的芯片区别最大的地方。x86中没有ldr这种指令，因为x86的mov指令可以将数据从内存中移动到寄存器中 

> `LDR r0, =0x12345678` 这个ldr是伪指令哦。表示__把0x12345678这个值__写到r0中了。ldr伪指令和mov是比较相似的。只不过mov指令限制了立即数的长度为8位，也就是不能超过512。而ldr伪指令没有这个限制。如果使用ldr伪指令时，后面跟的立即数没有超过8位，那么在实际汇编的时候该ldr伪指令是被转换为mov指令的.

> `LDR R0,=NAME` 表示将__NAME的地址__存入R0

> `LDR R0,=&0` 这个&不知道撒意思？

> LDR伪指令和LDR指令不是一个东西.

```
LD : load 加载，出栈操作
ST : store 存储，入栈操作
M : multi 多次
F: full 满栈，SP指向最后一个数据
E: empty 空栈，SP指向与最后一个数据相邻的下一个可写入存储单元
D: descending 递减，代表栈的增长方向
A: ascending 递增，代表栈的增长方向

作者：ajw
链接：https://www.jianshu.com/p/aa4695b6bc26
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
https://www.jianshu.com/p/aa4695b6bc26
https://blog.csdn.net/weiwei_xiaoyu/article/details/20563479
```

***

#指令条件码
| 助记符后缀 | 意义               |
| ---------- | ------------------ |
| EQ         | 相等               |
| NE         | 不相等             |
| CS         | 无符号数大于或等于 |
| CC         | 无符号数小于       |
| MI         | 负数               |
| PL         | 正数或零           |
| VS         | 溢出               |
| VC         | 未溢出             |
| HI         | 无符号数大于       |
| LS         | 无符号数小于或等于 |
| GE         | 带符号数大于或等于 |
| LT         | 带符号数小于       |
| GT         | 带符号数大于       |
| LE         | 带符号数小于或等于 |
| AL         | 无条件执行         |

#寻址方式
- 立即寻址
- 寄存器寻址 
- 寄存器间接寻址
- 基址变址寻址 
- 多寄存器寻址
- 相对寻址
- 堆栈寻址
***

#S标记：紧跟在指令后面，决定指令的操作是否影响 CPSR 中条件标志位的值,当没有 S 时指令不更新 CPSR 中条件标志位。
- MOVS : 表示mov指令需要更新cpsr的标志位
- ADCS ：表示带进位的加法需要同时更新cpsr中标记位，方便下一个计算时获取到进位标志。ADDS则表示本次计算不实用进位值，只更新cpsr中进位值。

#伪指令:包含符号定义伪指令、数据定义伪指令、汇编控制伪 指令、宏指令以及其他伪指令

#汇编控制伪指令用于控制汇编程序的执行流程,常用的汇编控制伪指令包括:
- IF、ELSE、ENDIF
- WHILE、WEND
- MACRO、MEND 定义一段宏，类似c语言中的宏函数。
- MEXIT 从宏内退出，这个c语言没有。

# 其他常用的伪指令：
- AREA  定义一个代码段或者数据段，并可以指定属性
- ALIGN 在AREA定义时用于指定对齐方式
- CODE16, CODE32 告诉编译器，时16位的thumb还是32位的arm指令
- ENTRY 指定汇编程序的入口，我觉得类似main函数吧
- END 指定汇编程序的结尾
- EQU 类似c中的＃define，给标号指定值。我觉得有点像数据定义伪指令的功能呢
- EXPORT(GLOBAL) 将符号导出，可以在其他文件中使用
- IMPORT 导入符号（无论是否真的使用，都会导入）
- EXTERN 导入符号（若没有真正使用，则不会导入）
- GET(INCLUDE) 类似c的include
- INCBIN 类似GET，但是编译器不会处理加入的文件，get会处理
- RN 给寄存器定义别名
- ROUT 扩展一下局部变量的作用域

#运算符：
- X=Y  表示X等于Y
- X<>Y 表示X不等于Y
- ：LEN：X   计算字符串X的长度
- :DEF:X  如果符号X已经定义了，则返回真，否则返回假
- 

#Tips
cpsr_c代表的是这32位中的低8位，也就是控制位
 

