========================================================================
工程功能说明：
提供windows平台下动态打桩功能

stub001:该文件夹下面提供的原始打桩代码，测试性质，不建议使用

stub002:该文件夹下面提供正式的打桩代码，可以支持同时对多个函数进行打桩

stub003:该文件夹下面是单个函数打桩的代码，是第二个的简化版

根目录下test_stub.c文件，提供了多种版本的测试代码，可以阅读这些代码了解如何使用动态打桩函数
本工程已经在vs 2008上面测试通过。
本工程也已经Mac系统的linux环境上验证通过，编译时需要注意指定为32位系统编译，否则在64位OS上有问题，请用如下指令编译：
gcc -m32 test_stub.c ./stub002/d_stub.c

PS：在代码中修改代码段的权限时使用了 PAGE_EXECUTE_READWRITE 而不是PAGE_READWRITE，因为后者在使能内存保护的系统上会报错
/////////////////////////////////////////////////////////////////////////////

动态打桩的原理简介：
当C代码编译产生机器码之后，存在于系统的code区，权限为read-only，产生的过程可以参考《深入理解计算机系统》，大致经过编译生成汇编代码（文本文件），
再生成机器码（二进制文件）这几个重要过程。比如函数A，产生汇编代码类似A：这样的代码块。
要实现动态打桩，让A函数执行的时候跳转到stub函数，就需要去修改函数A最终产生的机器码文件，当函数A被调用的时候立刻发生跳转，去调用stub函数。
所以这里需要这样几步操作：
1. 找到原函数A编译之后机器码的开始位置A_addr（即指针值），以及A所在code区的page（可能不止一个page），并设置其为可写的（可执行）状态。
2. 找到stub函数编译之后的开始位置stub_addr，这里因为是执行stub函数，所以不需要修改其权限。
3. 将函数A机器码的第一条指令篡改为JUMP跳转指令，并指定跳到stub函数的开始地址。
4. 在32位系统上，地址为32位的，即4个Byte，另外JUMP指令只有一个Byte，且他的机器码为0xE9，这样我们一共需要修改函数A机器码开始位置的5个Byte的数据。
5. 由于JUMP命令是一个相对跳转指令，后面的跳转地址得是相对地址，所以我们这样得到相对偏移： stub_addr - A_addr - 5 ，这里的5是因为A_addr开始的5个
   byte已经被我们修改占用，所以跳转指令之后的相对偏移要扣除这5个Byte。
6. 在Windows和Linux上，对于第一步中修改page权限的操作完全不同，需要调用OS提供的底层API，详情可参阅代码。
7. 在64位系统上，地址是8字节，不在是4字节，另外跳转指令的方式也有变化，本程序不适用，所以在编译时必须指定为编译成32位程序。
